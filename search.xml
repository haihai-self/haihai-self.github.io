<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubuntu下gcc版本管理</title>
    <url>/2020/09/20/%E6%9D%82%E8%AE%B0/Ubuntu%E4%B8%8Bgcc%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>直接使用<code>build essential</code>安装的<code>gcc/g++</code>在一些比较早期的项目编译的时候会出现版本不支持的情况下需要对版本版本进行升降级，网络上看到直接使用<code>rm</code>命令确实是够好笑的，之前也上过当，这里记录一下靠谱的方法。</p>
<a id="more"></a>
<ul>
<li><p>使用<code>sudo apt-get install</code>安装多个版本的<code>gcc</code></p>
</li>
<li><p>使用<code>ll /usr/bin/gcc*</code>命令查看系统中安装的<code>gcc/g++</code>版本</p>
</li>
<li><p>使用<code>update-alternatives</code></p>
<p><code>update-alternatives</code>是ubuntu中专门维护系统命令链接的工具，可以通过他很方便的设置系统默认命令的版本，通过数值<code>50</code>等设置优先级，优先级越大的级别越高，<code>--slava</code>命令确保<code>gcc/g++</code>是同一个版本 ,直接使用<code>sudo update-alternatives: --install</code>可以看到该命令的格式<code>update-alternatives: --install 需要 &lt;链接&gt; &lt;名称&gt; &lt;路径&gt; &lt;优先级&gt;</code>，所以可以使用如下命令链接到特定版不的<code>gcc</code></p>
<p><code>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7  70 --slave /usr/bin/g++ g++ /usr/bin/g++-7</code></p>
</li>
<li><p>验证是否安装成功</p>
<p>使用<code>gcc -v / g++ -v</code>查看是否安装成功，同时也可以使用<code>sudo update-alternatives --config gcc</code>命令查看添加的版本，此时也可以手动选择需要的版本</p>
<p><img src="/picture/2010/gccconfig.png" alt="gccconfig"></p>
</li>
<li><p>删除</p>
<p>需要删除某个版本的话，可以直接使用</p>
<p><code>sudo update-alternatives --remove gcc /usr/bin/gcc-7</code></p>
<p>也可以查看该命令个格式<code>update-alternatives: --remove 需要 &lt;名称&gt; &lt;路径&gt;</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下git-clone缓慢</title>
    <url>/2020/09/22/%E6%9D%82%E8%AE%B0/Ubuntu%E4%B8%8Bgit-clone%E7%BC%93%E6%85%A2/</url>
    <content><![CDATA[<p><code>git clone</code>缓慢的主要原因是国内<code>DNS</code>无法自动转跳到<code>github.global.ssl.fastly.net</code>，该域名被限制导致，通过在<code>/etc/hosts</code>加上对应的地址可以解决这个问题</p>
<a id="more"></a>

<ul>
<li><p>查询<code>github.global.ssl.fastly.net</code>对应域名的地址，在<code>shell</code>下输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup github.global.ssl.fastly.Net</span><br></pre></td></tr></table></figure>

<p>查询到对应的<code>ip</code>如：<code>151.101.77.194</code></p>
</li>
<li><p>查询<code>github.com</code>对应的域名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup github.com </span><br></pre></td></tr></table></figure>

<p>查询到对应的<code>ip</code>如：<code>13.229.188.59</code></p>
</li>
</ul>
<p>最后在<code>hosts</code>文件尾加上两行如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">151.101.77.194 http://global-ssl.fastly.net</span><br><span class="line">13.229.188.59  http://github.com</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>typora安装新主题</title>
    <url>/2020/09/22/%E6%9D%82%E8%AE%B0/typora%E5%AE%89%E8%A3%85%E6%96%B0%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p>在文件选项中找到偏好设置中的外观设置，点击<code>获取主题</code>，下载喜欢的主题，在打开主题中的<code>打开主题文件夹</code>，会打开对应的文件夹，再将对应的文件复制到文件夹中即可。</p>
<a id="more"></a>
<p><img src="/picture/2010/typora%E4%B8%BB%E9%A2%98.png" alt="typora主题"></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu20.01搜狗输入法安装</title>
    <url>/2020/09/22/%E6%9D%82%E8%AE%B0/ubuntu20-01%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>在<a href="https://pinyin.sogou.com/linux/?r=pinyin">官网</a>下载对应的<code>deb</code>安装包，直接使用<code>dpkg</code>进行安装，会发现出现错误提示安装失败，因为搜狗输入法使用的是<code>fcitx</code>框架，对应的框架没有安装完成所以无法安装成功。</p>
<a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i sogoupinyin_2.3.2.07_amd64.deb</span><br></pre></td></tr></table></figure>

<p>在出现错误之后，使用如下命令安装<code>fcitx</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install --fix-broken</span><br></pre></td></tr></table></figure>

<p>在重新使用<code>dpkg</code>命令进行安装</p>
<p>安装成功之后，在右上角的配置栏中找到搜狗输入法，添加到第一项，同时按照自己的习惯配置激活按钮即可。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>config</title>
    <url>/2020/09/22/chipyard/config/</url>
    <content><![CDATA[<p>config是chipyard中的配置查找模块，实现了具体的查询逻辑</p>
<a id="more"></a>

<p>在文件</p>
<blockquote>
<p>generators/rocket-chip/api-config-chipsalliance/design/craft/src/config/Config.scala中。</p>
</blockquote>
<p><img src="/picture/2010/image-20200915091035763.png" alt="image-20200915105005563">由图中可以看出View/Field/Parameter为抽象类，不能进行实例化，view的直接子类有TerminalView/ChainView/Parameter，其中TerminalView/ChainView为私有类，只能在config包内进行访问，没有子类，而Parameter的子类有</p>
<blockquote>
<p>Config/ChainParameters/EmptyParameters/PartialParameters/MapParameters。</p>
</blockquote>
<p>以上的所有类中，暴露给外界的接口为Parameter的子类Config，其他的不是私有类就是抽象类，不能给外界继承。该package的主要目的是为了查找</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseConfig</span> <span class="keyword">extends</span> <span class="title">Config</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">  new <span class="type">WithDefaultMemPort</span>(</span>) <span class="title">++</span></span></span><br><span class="line"><span class="class">  <span class="title">new</span> <span class="title">WithDefaultMMIOPort</span>(<span class="params"></span>) <span class="title">++</span></span></span><br><span class="line"><span class="class">  <span class="title">new</span> <span class="title">WithDefaultSlavePort</span>(<span class="params"></span>) <span class="title">++</span></span></span><br><span class="line"><span class="class">  <span class="title">new</span> <span class="title">WithTimebase</span>(<span class="params"><span class="type">BigInt</span>(1000000</span>)) <span class="title">++</span> <span class="title">//</span> 1 <span class="title">MHz</span></span></span><br><span class="line"><span class="class">  <span class="title">new</span> <span class="title">WithDTS</span>(<span class="params">&quot;freechips,rocketchip-unknown&quot;, <span class="type">Nil</span></span>) <span class="title">++</span></span></span><br><span class="line"><span class="class">  <span class="title">new</span> <span class="title">WithNExtTopInterrupts</span>(<span class="params">2</span>) <span class="title">++</span></span></span><br><span class="line"><span class="class">  <span class="title">new</span> <span class="title">BaseSubsystemConfig</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="class">)</span></span><br></pre></td></tr></table></figure>

<p>可以看到BaseConfig继承了Config类，使用了其中的<code>++</code>方法构造View链，在使用其中的内部查找方法，返回View。</p>
<h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><p>View中的主要数据结构，为待查找的对象</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Field</span>[<span class="type">T</span>] <span class="title">private</span> (<span class="params">val default: <span class="type">Option</span>[<span class="type">T</span>]</span>)</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="type">None</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(<span class="keyword">default</span>: <span class="type">T</span>) = <span class="keyword">this</span>(<span class="type">Some</span>(<span class="keyword">default</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收一个Option的值，其中有两个辅助构造方法，无参的构造方法返回None，有参数的构造方法返回对应的值。</p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>为配置视图，通过View才能看到配置，进行查找。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](pname: <span class="type">Field</span>[<span class="type">T</span>]): <span class="type">T</span> = apply(pname, <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](pname: <span class="type">Field</span>[<span class="type">T</span>], site: <span class="type">View</span>): <span class="type">T</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> out = find(pname, site)</span><br><span class="line">    require (out.isDefined, <span class="string">s&quot;Key <span class="subst">$&#123;pname&#125;</span> is not defined in Parameters&quot;</span>)</span><br><span class="line">    out.get</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">lift</span></span>[<span class="type">T</span>](pname: <span class="type">Field</span>[<span class="type">T</span>]): <span class="type">Option</span>[<span class="type">T</span>] = lift(pname, <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">lift</span></span>[<span class="type">T</span>](pname: <span class="type">Field</span>[<span class="type">T</span>], site: <span class="type">View</span>): <span class="type">Option</span>[<span class="type">T</span>] = find(pname, site).map(_.asInstanceOf[<span class="type">T</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>[config] <span class="function"><span class="keyword">def</span> <span class="title">find</span></span>[<span class="type">T</span>](pname: <span class="type">Field</span>[<span class="type">T</span>], site: <span class="type">View</span>): <span class="type">Option</span>[<span class="type">T</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了两个apply方法，其中第一个只接收待查找的对象，第二个接收待查找的对象跟需要查找的View，但是第一个apply会调用第二个apply方法，待查找的对象为本身this。</p>
<p>第二个apply方法会调用内部的find方法，find接收待查找对象跟需要查找的 View，返回一个Option的值，在View中定义的find为抽象类，具体实现是在他的子类中。</p>
<h3 id="TerminalView"><a href="#TerminalView" class="headerlink" title="TerminalView"></a>TerminalView</h3><p>为View的三个子类之一，实现了find方法。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">find</span></span>[<span class="type">T</span>](pname: <span class="type">Field</span>[<span class="type">T</span>], site: <span class="type">View</span>): <span class="type">Option</span>[<span class="type">T</span>] = pname.<span class="keyword">default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表示的是要是在链表中找不到对应的View的话，返回default的值，而最后的Filed必然是调用空的构造函数，所以最终查找不到将会返回None</p>
<h3 id="ChainView"><a href="#ChainView" class="headerlink" title="ChainView"></a>ChainView</h3><p>这是想把两个View结合在一起。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainView</span>(<span class="params">head: <span class="type">Parameters</span>, tail: <span class="type">View</span></span>) <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">find</span></span>[<span class="type">T</span>](pname: <span class="type">Field</span>[<span class="type">T</span>], site: <span class="type">View</span>) = head.chain(site, tail, pname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收一个parameters与一个View，实现了find方法，find方法就是调用parameters中的chain方法</p>
<h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p>Parameters为View的子类，实现了find方法.</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Parameters</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">++</span> </span>(x: <span class="type">Parameters</span>): <span class="type">Parameters</span> =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ChainParameters</span>(<span class="keyword">this</span>, x)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">alter</span></span>(f: (<span class="type">View</span>, <span class="type">View</span>, <span class="type">View</span>) =&gt; <span class="type">PartialFunction</span>[<span class="type">Any</span>,<span class="type">Any</span>]): <span class="type">Parameters</span> =</span><br><span class="line">    <span class="type">Parameters</span>(f) ++ <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">alterPartial</span></span>(f: <span class="type">PartialFunction</span>[<span class="type">Any</span>,<span class="type">Any</span>]): <span class="type">Parameters</span> =</span><br><span class="line">    <span class="type">Parameters</span>((_,_,_) =&gt; f) ++ <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">alterMap</span></span>(m: <span class="type">Map</span>[<span class="type">Any</span>,<span class="type">Any</span>]): <span class="type">Parameters</span> =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">MapParameters</span>(m) ++ <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>[config] <span class="function"><span class="keyword">def</span> <span class="title">chain</span></span>[<span class="type">T</span>](site: <span class="type">View</span>, tail: <span class="type">View</span>, pname: <span class="type">Field</span>[<span class="type">T</span>]): <span class="type">Option</span>[<span class="type">T</span>]</span><br><span class="line">  <span class="keyword">protected</span>[config] <span class="function"><span class="keyword">def</span> <span class="title">find</span></span>[<span class="type">T</span>](pname: <span class="type">Field</span>[<span class="type">T</span>], site: <span class="type">View</span>) = chain(site, <span class="keyword">new</span> <span class="type">TerminalView</span>, pname)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Parameters</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">empty</span></span>: <span class="type">Parameters</span> = <span class="keyword">new</span> <span class="type">EmptyParameters</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(f: (<span class="type">View</span>, <span class="type">View</span>, <span class="type">View</span>) =&gt; <span class="type">PartialFunction</span>[<span class="type">Any</span>,<span class="type">Any</span>]): <span class="type">Parameters</span> = <span class="keyword">new</span> <span class="type">PartialParameters</span>(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>chain是一个抽象方法为一个链式查找逻辑，其中site表示当前要查找的Veiw，tail表示下一个要查找的View，pname为需要查找的对象。</li>
<li>find将查找逻辑代理给chain方法，所以具体的查找逻辑最终还是在Parameters的子类当中。</li>
<li>++方法将一个Parameters传递给子类的ChainParameters，将Parameters组成链。</li>
<li>PartialFunction[Any, Any]接受一个Any类型的参数，返回一个Any类型的变量。</li>
<li>alter的参数列表中，是一个偏函数，接收一个f，返回一个PartialFunction。</li>
<li>alterPartial中的参数列表表示接收的是一个PartialFunction，这个PartialFunction接收一个Any类型，返回一个Any类型<ul>
<li>上面两个函数，内部都调用了伴生对象中的apply方法，内部调用了PatialParameters</li>
</ul>
</li>
<li>最后alterMap接收一个Map类型的对象调用子类MapParameters之后在调用++方法。</li>
</ul>
<p>最后parameters的调用方法如下所示</p>
<p><img src="/picture/2010/image-20200915105005563.png" alt="image-20200915105005563"></p>
<h4 id="EmptyParameters"><a href="#EmptyParameters" class="headerlink" title="EmptyParameters"></a>EmptyParameters</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyParameters</span> <span class="keyword">extends</span> <span class="title">Parameters</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">chain</span></span>[<span class="type">T</span>](site: <span class="type">View</span>, tail: <span class="type">View</span>, pname: <span class="type">Field</span>[<span class="type">T</span>]) = tail.find(pname, site)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在没有配置项的情况下，直接在下一个View中进行查找，调用tail的find方法。</p>
<h4 id="PartialParameter"><a href="#PartialParameter" class="headerlink" title="PartialParameter"></a>PartialParameter</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PartialParameters</span>(<span class="params">f: (<span class="type">View</span>, <span class="type">View</span>, <span class="type">View</span></span>) <span class="title">=&gt;</span> <span class="title">PartialFunction</span>[<span class="type">Any</span>,<span class="type">Any</span>]) <span class="keyword">extends</span> <span class="title">Parameters</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span>[config] <span class="function"><span class="keyword">def</span> <span class="title">chain</span></span>[<span class="type">T</span>](site: <span class="type">View</span>, tail: <span class="type">View</span>, pname: <span class="type">Field</span>[<span class="type">T</span>]) = &#123;</span><br><span class="line">    <span class="keyword">val</span> g = f(site, <span class="keyword">this</span>, tail)</span><br><span class="line">    <span class="keyword">if</span> (g.isDefinedAt(pname)) <span class="type">Some</span>(g.apply(pname).asInstanceOf[<span class="type">T</span>]) <span class="keyword">else</span> tail.find(pname, site)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数参数为一个成员函数，类型为(View, View, View) =&gt; PartialFunction(Any, Any)</p>
<ul>
<li>接收三个类型为View的参数</li>
<li>返回一个PartialFunction</li>
</ul>
<p>实现的chain方法的查找逻辑是首先生成一个匹配函数g，g是一个PartialFunction，使用isDefineAt方法查找是否匹配当前View，若不匹配，在下一个View中查找</p>
<h4 id="MapParameters"><a href="#MapParameters" class="headerlink" title="MapParameters"></a>MapParameters</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MapParameters</span>(<span class="params">map: <span class="type">Map</span>[<span class="type">Any</span>, <span class="type">Any</span>]</span>) <span class="keyword">extends</span> <span class="title">Parameters</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span>[config] <span class="function"><span class="keyword">def</span> <span class="title">chain</span></span>[<span class="type">T</span>](site: <span class="type">View</span>, tail: <span class="type">View</span>, pname: <span class="type">Field</span>[<span class="type">T</span>]) = &#123;</span><br><span class="line">    <span class="keyword">val</span> g = map.get(pname)</span><br><span class="line">    <span class="keyword">if</span> (g.isDefined) <span class="type">Some</span>(g.get.asInstanceOf[<span class="type">T</span>]) <span class="keyword">else</span> tail.find(pname, site)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个跟上一个类似，但是使用的是Map查找而不是PartialFunction，若当前View存在返回，不匹配的话将在下一个View中查找。</p>
<h4 id="ChainParameters"><a href="#ChainParameters" class="headerlink" title="ChainParameters"></a>ChainParameters</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainView</span>(<span class="params">head: <span class="type">Parameters</span>, tail: <span class="type">View</span></span>) <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">find</span></span>[<span class="type">T</span>](pname: <span class="type">Field</span>[<span class="type">T</span>], site: <span class="type">View</span>) = head.chain(site, tail, pname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数接收两个参数的Parameters，他将两个Parameter连接起来，首先在x中进行查找，再在y中进行查找。</p>
<h4 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h4><p>最后是暴露给外界的查找接口Config</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span>(<span class="params">p: <span class="type">Parameters</span></span>) <span class="keyword">extends</span> <span class="title">Parameters</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(f: (<span class="type">View</span>, <span class="type">View</span>, <span class="type">View</span>) =&gt; <span class="type">PartialFunction</span>[<span class="type">Any</span>,<span class="type">Any</span>]) = <span class="keyword">this</span>(<span class="type">Parameters</span>(f))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>[config] <span class="function"><span class="keyword">def</span> <span class="title">chain</span></span>[<span class="type">T</span>](site: <span class="type">View</span>, tail: <span class="type">View</span>, pname: <span class="type">Field</span>[<span class="type">T</span>]) = p.chain(site, tail, pname)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="keyword">this</span>.getClass.getSimpleName</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toInstance</span> </span>= <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两种构造方法，第一种是字节传入一个Parameters，这种方法会直接调用chain方法进行查找，另外一个辅助构造方法接收三个参数的View，这将调用Parameter的伴生对象中的apply方法进行查找，与alterPartial类似。</p>
<h2 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h2><ul>
<li><p>直接调用Parameters的伴生对象中的apple方法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseSubsystemConfig</span> <span class="keyword">extends</span> <span class="title">Config</span> (<span class="params">(site, here, up</span>) <span class="title">=&gt;</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Tile parameters</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">PgLevels</span> =&gt; <span class="keyword">if</span> (site(<span class="type">XLen</span>) == <span class="number">64</span>) <span class="number">3</span> <span class="comment">/* Sv39 */</span> <span class="keyword">else</span> <span class="number">2</span> <span class="comment">/* Sv32 */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">XLen</span> =&gt; <span class="number">64</span> <span class="comment">// Applies to all cores</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">MaxHartIdBits</span> =&gt; log2Up(site(<span class="type">RocketTilesKey</span>).size)</span><br><span class="line">  <span class="comment">// Interconnect parameters</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">SystemBusKey</span> =&gt; <span class="type">SystemBusParams</span>(</span><br><span class="line">    beatBytes = site(<span class="type">XLen</span>)/<span class="number">8</span>,</span><br><span class="line">    blockBytes = site(<span class="type">CacheBlockBytes</span>))</span><br><span class="line">  <span class="keyword">case</span> <span class="type">ControlBusKey</span> =&gt; <span class="type">PeripheryBusParams</span>(</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>由于apply方法返回的是一个PartialFunction，所以使用可以使用case方法判断查询到了具体的哪个对象</p>
</li>
<li><p>添加配置</p>
<p>Config类继承了Parameters中的<code>++</code>方法，所以可以直接使用该方法来添加View</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseConfig</span> <span class="keyword">extends</span> <span class="title">Config</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">  new <span class="type">WithDefaultMemPort</span>(</span>) <span class="title">++</span></span></span><br><span class="line"><span class="class">  <span class="title">new</span> <span class="title">WithDefaultMMIOPort</span>(<span class="params"></span>) <span class="title">++</span></span></span><br><span class="line"><span class="class">  <span class="title">new</span> <span class="title">WithDefaultSlavePort</span>(<span class="params"></span>) <span class="title">++</span></span></span><br><span class="line"><span class="class">  <span class="title">new</span> <span class="title">WithTimebase</span>(<span class="params"><span class="type">BigInt</span>(1000000</span>)) <span class="title">++</span> <span class="title">//</span> 1 <span class="title">MHz</span></span></span><br><span class="line"><span class="class">  <span class="title">new</span> <span class="title">WithDTS</span>(<span class="params">&quot;freechips,rocketchip-unknown&quot;, <span class="type">Nil</span></span>) <span class="title">++</span></span></span><br><span class="line"><span class="class">  <span class="title">new</span> <span class="title">WithNExtTopInterrupts</span>(<span class="params">2</span>) <span class="title">++</span></span></span><br><span class="line"><span class="class">  <span class="title">new</span> <span class="title">BaseSubsystemConfig</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="class">)</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>config中实现了查找的逻辑，与外部的调用site，here，up相对应，实现了两种查找方法，一种是递归动态的查找，使用的是PartialFunction技术，一种是静态的查找，直接使用Map中的映射进行。</p>
]]></content>
      <categories>
        <category>chipyard</category>
      </categories>
      <tags>
        <tag>chipyard</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么scala</title>
    <url>/2020/09/22/scala/scala%E7%BC%96%E7%A8%8B/%E4%B8%BA%E4%BB%80%E4%B9%88scala/</url>
    <content><![CDATA[<p>scala不是一门纯粹的面向对象的语言，他强调函数式编程，函数式编程的两大核心理念是函数是一等的，以及程序中应该将值直接映射到输出，尽量的减少在函数中对程序的副作用。</p>
<a id="more"></a>
<ul>
<li><p>一等函数</p>
<p>函数可以做为别的函数的参数、返回值，赋值给变量</p>
</li>
<li><p>直接映射到输出</p>
<p>操作直接将输入值映射到输出值，而不是当场修改数据。</p>
</li>
</ul>
<p><strong>变量定义</strong>：变量分为两种，一周是val类型，一种是var类型，val类型一旦被初始化就不能修改其值，var类型在整个生命周期之内都可以被重新赋值。</p>
<p><strong>函数定义</strong>：def开始，接下来是函数名，之后吃参数列表，紧跟一个冒号，之后是返回类型，接下来是等号，花括号之内是函数体</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(x: int, y:<span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span>(x &gt; y)</span><br><span class="line">    x</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数字面量</strong>：用圆括号括起来一组带名字的参数，一个又箭头和函数体</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">(x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y</span><br></pre></td></tr></table></figure>

<p><strong>foreach,跟for遍历</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">args.foreach(arg =&gt; println(arg))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(arg &lt;- args)</span><br><span class="line">	println(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">2</span>)</span><br><span class="line">	println(i)</span><br><span class="line"><span class="comment">//for括号中，左边是变量，右边是数组</span></span><br></pre></td></tr></table></figure>

<p>方法调用：在scala中并没有操作符重载，1 + 2被解释成(1).+(2)调用Int的+方法</p>
<p><strong>从文件读取文本行</strong>：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"><span class="keyword">if</span>(args.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(line &lt;- <span class="type">Source</span>.fromFile(args(<span class="number">0</span>)).getLines())</span><br><span class="line">    println(line.length + <span class="string">&quot; &quot;</span> + line)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  <span class="type">Console</span>.err.println(<span class="string">&quot;please enter filename&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala编程</tag>
      </tags>
  </entry>
  <entry>
    <title>scala-implicit</title>
    <url>/2020/09/22/scala/scala%E8%AF%AD%E6%B3%95%E7%B3%96/scala-implicit/</url>
    <content><![CDATA[<p>方法可以具有 <em>隐式</em> 参数列表，由参数列表开头的 <em>implicit</em> 关键字标记。 如果参数列表中的参数没有像往常一样传递， Scala 将查看它是否可以获得正确类型的隐式值，如果可以，则自动传递。</p>
<p>Scala 将查找这些参数的位置分为两类：</p>
<ul>
<li>Scala 在调用包含有隐式参数块的方法时，将首先查找可以直接访问的隐式定义和隐式参数 (无前缀)。</li>
<li>然后，它在所有伴生对象中查找与隐式候选类型相关的有隐式标记的成员。</li>
</ul>
<a id="more"></a>

<p>更加详细的关于 Scala 到哪里查找隐式参数的指南请参考 <a href="https://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html">常见问题</a></p>
<p>在下面的例子中，我们定义了一个方法 <code>sum</code>，它使用 Monoid 类的 <code>add</code> 和 <code>unit</code> 方法计算一个列表中元素的总和。 请注意，隐式值不能是顶级值。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Monoid</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">A</span>, y: <span class="type">A</span>): <span class="type">A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>: <span class="type">A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> stringMonoid: <span class="type">Monoid</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">String</span>, y: <span class="type">String</span>): <span class="type">String</span> = x concat y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> intMonoid: <span class="type">Monoid</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = x + y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>[<span class="type">A</span>](xs: <span class="type">List</span>[<span class="type">A</span>])(<span class="keyword">implicit</span> m: <span class="type">Monoid</span>[<span class="type">A</span>]): <span class="type">A</span> =</span><br><span class="line">    <span class="keyword">if</span> (xs.isEmpty) m.unit</span><br><span class="line">    <span class="keyword">else</span> m.add(xs.head, sum(xs.tail))</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(sum(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)))       <span class="comment">// uses IntMonoid implicitly</span></span><br><span class="line">    println(sum(<span class="type">List</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>))) <span class="comment">// uses StringMonoid implicitly</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 <code>Monoid</code> 定义了一个名为 <code>add</code> 的操作，它将一对 <code>A</code> 类型的值相加并返回一个 <code>A</code>，以及一个名为 <code>unit</code> 的操作，用来创建一个（特定的）<code>A</code> 类型的值。</p>
<p>为了说明隐式参数如何工作，我们首先分别为字符串和整数定义 Monoid 实例， <code>StringMonoid</code> 和 <code>IntMonoid</code>。 <code>implicit</code> 关键字表示可以隐式使用相应的对象。</p>
<p>方法 <code>sum</code> 接受一个 <code>List[A]</code>，并返回一个 <code>A</code> 的值，它从 <code>unit</code> 中取初始的 <code>A</code> 值，并使用 <code>add</code> 方法依次将列表中的下一个 <code>A</code> 值相加。在这里将参数 <code>m</code> 定义为隐式意味着，如果 Scala 可以找到隐式 <code>Monoid[A]</code> 用于隐式参数 <code>m</code>，我们在调用 <code>sum</code> 方法时只需要传入 <code>xs</code> 参数。</p>
<p>在 <code>main</code> 方法中我们调用了 <code>sum</code> 方法两次，并且只传入参数 <code>xs</code>。 Scala 会在上例的上下文范围内寻找隐式值。 第一次调用 <code>sum</code> 方法的时候传入了一个 <code>List[Int]</code> 作为 <code>xs</code> 的值，这意味着此处类型 <code>A</code> 是 <code>Int</code>。 隐式参数列表 <code>m</code> 被省略了，因此 Scala 将查找类型为 <code>Monoid[Int]</code> 的隐式值。 第一查找规则如下</p>
<blockquote>
<p>Scala 在调用包含有隐式参数块的方法时，将首先查找可以直接访问的隐式定义和隐式参数 (无前缀)。</p>
</blockquote>
<p><code>intMonoid</code> 是一个隐式定义，可以在<code>main</code>中直接访问。 并且它的类型也正确，因此它会被自动传递给 <code>sum</code> 方法。</p>
<p>第二次调用 <code>sum</code> 方法的时候传入一个 <code>List[String]</code>，这意味着此处类型 <code>A</code> 是 <code>String</code>。 与查找 <code>Int</code> 型的隐式参数时类似，但这次会找到 <code>stringMonoid</code>，并自动将其作为 <code>m</code> 传入。</p>
<p>该程序将输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<p><img src="/picture/2010/image-20200922001335357.png" alt="image-20200922001335357"></p>
<p><img src="/picture/2010/image-20200922001451905.png" alt="image-20200922001451905"></p>
]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala-常用语法</tag>
      </tags>
  </entry>
  <entry>
    <title>scala-lazy</title>
    <url>/2020/09/22/scala/scala%E8%AF%AD%E6%B3%95%E7%B3%96/scala-lazy/</url>
    <content><![CDATA[<ul>
<li><p><strong>初始化顺序问题</strong></p>
<p>构造顺序的问题，要是变量在类中没有初始化就使用他，这个时候会产生错误，使用<code>lazy</code>关键字很好的回避了这个问题，在用到的时候在进行初始化，保证了在用到该变量之前依赖的变量已经完成初始化。</p>
<a id="more"></a>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">val</span> name_len = name.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时要是在<code>main</code>中新建一个<code>Student</code>的类会出现异常，因为父类会先于子类进行构造，在执行<code>name.length</code>的时候试图查找一个空指针的长度，出现异常</p>
<p>想要解决这个问题需要将<code>name_len</code>加上<code>lazy</code>关键字，这样的就可以保证其初始化的顺序。</p>
<p><code>lazy val name_len = name.length</code></p>
</li>
<li><p><strong>初始化某个变量的时间过长</strong></p>
<p>在类的初始化过程中，要是有某个类初始化时间过长，可以申明为<code>lazy</code>这样的话，只有在使用他的第一次才进行初始化，显著减少了初始化的执行时间</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> properties = &#123;</span><br><span class="line">    print(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>properties</code>变量声明为<code>lazy</code>将会使其在使用的时候才对其进行初始化</p>
</li>
<li><p><strong>缺点</strong></p>
<p>每次使用前都会检查是否已经初始化，会有额外的开销，并没有那么高效</p>
</li>
</ul>
]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala语法</tag>
      </tags>
  </entry>
  <entry>
    <title>scala内建控制</title>
    <url>/2020/09/22/scala/scala%E7%BC%96%E7%A8%8B/scala%E5%86%85%E5%BB%BA%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>内建控制主要是在if或者是for字句中加入控制语句，来实现过滤，条件筛选等操作</p>
<a id="more"></a>

<ul>
<li><p><strong>if表达式</strong></p>
<p>首先测试条件，根据条件是否满足来执行两个不同代码分支中的一个</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">println(<span class="keyword">if</span> (!args.isEnpty) args(<span class="number">0</span>) <span class="keyword">else</span> <span class="string">&quot;default.txt&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>for循环</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (file &lt;- filesName)</span><br><span class="line">	println(file)</span><br></pre></td></tr></table></figure>

<p>像<code>file &lt;- filesName</code>这样的语法是生成器，遍历filsname中的所有元素</p>
</li>
<li><p><strong>过滤</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (file &lt;- filesName <span class="keyword">if</span> file.getName.endWith(<span class="string">&quot;.scala&quot;</span>))</span><br><span class="line">	println(file)</span><br></pre></td></tr></table></figure>

<p>使用if子句进行过滤</p>
</li>
<li><p><strong>嵌套循环</strong></p>
<p>使用多个<code>&lt;-</code>子句，将会先遍历外层迭代器，在根据条件遍历内层迭代器，还可以在中途绑定变量。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (</span><br><span class="line">	file &lt;- filesName</span><br><span class="line">	<span class="keyword">if</span> file.getName.endWith(<span class="string">&quot;.scala&quot;</span>)</span><br><span class="line">	line &lt;- fileLines(file)</span><br><span class="line">    trimed = line.trim</span><br><span class="line">	<span class="keyword">if</span> trimed.matchs(pattern)</span><br><span class="line">)println(file + <span class="string">&quot;:&quot;</span> line.trim)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>产出一个新的集合</strong></p>
<p>在for循环的后面加上<code>yield</code>关键字将会产生一个集合，如<code>for</code> 子句 <code>yield</code> 代码体</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scalaFiles</span> </span>= </span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">        file &lt;- filesName</span><br><span class="line">        <span class="keyword">if</span> file.getName.endsWith(<span class="string">&quot;.scala&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">yield</span> file</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>捕获处理异常</strong></p>
<p>try：代码体</p>
<p>cache：捕获处理异常，且里面用cace进行匹配</p>
<p>finally：不管咋样都要执行的代码</p>
</li>
<li><p><strong>没有break跟continue</strong></p>
<p>通过使用变量<code>var</code>来进行控制，要是实在是需要break支持，可以在<code>scala.util.control.Braks._</code>中找到</p>
</li>
</ul>
]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala编程</tag>
      </tags>
  </entry>
  <entry>
    <title>scala函数式对象</title>
    <url>/2020/09/22/scala/scala%E7%BC%96%E7%A8%8B/scala%E5%87%BD%E6%95%B0%E5%BC%8F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>如果一个类没有定义体，并不需要给出花括号，因为没有显示的构造方法，若需要检查一些前置条件的话，需要用到<code>require</code>这个方法</p>
<a id="more"></a>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">n: <span class="type">Int</span>, d: <span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">	require(d != <span class="number">0</span>)  <span class="comment">//检查分母不能为0</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= n + <span class="string">&quot;/&quot;</span> + d <span class="comment">//没有参数的话可以直接写 =</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>n, d</code>做为类参数，scala编译器会自动采集到这两个参数，并创建一个主构造方法，同时接受这两个参数。</p>
<p>重写<code>toString</code>方法：因为编写一个类之后，新建他会打印初该类的一些默认信息，要是没有从写<code>toString</code>方法的话会导致打印的只是地址</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">n: <span class="type">Int</span>, d: <span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= n + <span class="string">&quot;/&quot;</span> + d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>辅助构造方法</strong>：相当于多态，以<code>def this</code>打头，但是辅助构造放法必须调用<code>主构造方法</code>或者调用同一个类中的<code>另外一个构造方法</code>，但这个构造方法最终还是会调用主构造方法，主构造方法是类的单一入口，因为只有主构造方法才能调用<code>超类</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">n: <span class="type">Int</span>, d: <span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(n: <span class="type">Int</span>) = <span class="keyword">this</span>(n, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变量定义</strong>：先申明为<code>val或var</code>之后定义标识符，最后定义类型，若是val需要给出初始化参数（正常情况下），但是要是标识符以下划线结尾，需要再标识符与冒号之间加上<code>空格</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> n: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> n_ : <span class="type">Int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>隐式转换</strong>：重载了操作符之后就可以进行运算了，比如 r * 2这样的方法没问题，操作符的左结核性会调用r对应的 * 方法，但是使用2 * r 这样的方法并不行，因为Int类型并没有定义 * r的方法，若想调用，需要加入隐式转换</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">intToRational</span></span>(x: <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">Rational</span>(x)</span><br></pre></td></tr></table></figure>

<p>该方法将int转换为Rational类型，之后在调用Rational的 * 方法 </p>
<p>Rational程序例子：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">d: <span class="type">Int</span>, n: <span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">  require(d != <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> g = gcd(n.abs, d.abs)</span><br><span class="line">  <span class="keyword">val</span> numer = n / g</span><br><span class="line">  <span class="keyword">val</span> denom = d / g</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(n: <span class="type">Int</span>) = <span class="keyword">this</span>(n, <span class="number">1</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">+</span> </span>(that: <span class="type">Rational</span>): <span class="type">Rational</span> = </span><br><span class="line">    <span class="keyword">new</span> <span class="type">Rational</span>(</span><br><span class="line">      numer * that.denom + that.numer * denom,</span><br><span class="line">      denom * that.denom</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">+</span> </span>(i: <span class="type">Int</span>):<span class="type">Rational</span> = </span><br><span class="line">    <span class="keyword">new</span> <span class="type">Rational</span>(numer + i * denom, denom)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">-</span> </span>(that: <span class="type">Rational</span>): <span class="type">Rational</span> = </span><br><span class="line">    <span class="keyword">new</span> <span class="type">Rational</span>(numer * that.denom - that.numer * denom,</span><br><span class="line">      denom * that.denom)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">-</span> </span>(i: <span class="type">Int</span>): <span class="type">Rational</span> = </span><br><span class="line">    <span class="keyword">new</span> <span class="type">Rational</span>(numer - i * denom, denom)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">*</span> </span>(that: <span class="type">Rational</span>): <span class="type">Rational</span> =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Rational</span>(numer * that.numer, denom * that.denom)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">*</span> </span>(i: <span class="type">Int</span>): <span class="type">Rational</span> = </span><br><span class="line">    <span class="keyword">new</span> <span class="type">Rational</span>(numer * i, denom)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">/</span> </span>(that: <span class="type">Rational</span>): <span class="type">Rational</span> = </span><br><span class="line">    <span class="keyword">new</span> <span class="type">Rational</span>(numer * that.denom, denom * that.numer)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">/</span> </span>(i: <span class="type">Int</span>): <span class="type">Rational</span> =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Rational</span>(numer, denom * i)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= numer + <span class="string">&quot;/&quot;</span> + denom</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">gcd</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) a <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala编程</tag>
      </tags>
  </entry>
  <entry>
    <title>scala类跟基础操作</title>
    <url>/2020/09/22/scala/scala%E7%BC%96%E7%A8%8B/scala%E7%B1%BB%E8%B7%9F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>类跟其他面向对象的语言其实是一样的，但是要注意的是单例对象，基础操作将介绍一些scala中基本的术语</p>
<a id="more"></a>

<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><strong>类的定义</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125; <span class="comment">//类的A定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> a = <span class="keyword">new</span> <span class="type">ClassName</span>() <span class="comment">//实例化</span></span><br><span class="line"></span><br><span class="line">a.method <span class="comment">//调用字段方法</span></span><br></pre></td></tr></table></figure>

<p>若是定义的返回值位uint，其作用就是强调函数的副作用，要是没有<code>return</code>语句，将会将函数中最后的结果做为返回值</p>
<p><strong>单例对象</strong></p>
<p>当有同名类时，单例对象位伴生对象，可以访问<code>伴生类</code>的所有成员变量，其可以存放静态方法，类中不能有静态方法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ObjectName</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若无<code>伴生类</code>则位孤立对象，其中可以用maim方法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Summer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">    <span class="keyword">for</span>(arg &lt;- args)</span><br><span class="line">      println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直接使用scala命令进行编译，时间会比较长，因为他会遍历jar所有的包，使用<code>fsc</code>进行编译，第一次时间比较长，之后会创建一个<code>守护进程</code>若是程序没有改动，则时间上会很快</p>
<h2 id="基础类型跟操作"><a href="#基础类型跟操作" class="headerlink" title="基础类型跟操作"></a>基础类型跟操作</h2><ul>
<li><p><strong>字面量</strong>：是表达源码中一个固定值的方法</p>
</li>
<li><p><strong>字符串字面量</strong>：这里需要注意的是若是有 <code>&quot;&quot;&quot;</code>括起来的字符串将不会进行转译</p>
</li>
<li><p><strong>符号字面量</strong>：<code>&#39;ident</code>这样的形势，用来再动态语言中当作标识符的场合</p>
</li>
<li><p><strong>字符串插值</strong>：<code>s&quot; $name&quot;</code>将回去寻找变量name，对字符串中的<code>name</code>进行插值，还可以使用f插值如<code>f&quot;&#123;math.Pi&#125;%.5f&quot;</code>进行printf风格的插值，row插值将不会对<code>\</code>进行转译</p>
</li>
<li><p><strong>操作符即方法</strong></p>
<p>调用1 + 3 这样的方法，会调用<code>1.+(3)</code>，同时，任何方法都是操作符，<code>s.indexOf(&#39;o&#39;)</code>可以写成<code>s indexOf &#39;o&#39;</code></p>
<p>前缀标识符：+ - ! ~ 会表示成<code>p.unary_!</code>这样的类似形式g</p>
<p>后缀标识符是那些不接受参数且再调用时没有英文句点圆括号的方法，可以再调用的时候省区圆括号，如<code>s.length</code>返回字符串<code>s</code>的长度</p>
</li>
<li><p><strong>无符号右移</strong>： <code>&gt;&gt;&gt;</code>左移跟无符号右移都会自动填充0</p>
</li>
<li><p><strong>对象相等</strong>：直接使用<code>==</code>的方法，可以直接比较对象的内容上相等。</p>
</li>
<li><p><strong>结合性</strong>：任何<code>:</code>的方法都由他右边的对象调用，传入左侧的操作元。<code>a:::b</code>将会是<code>b.:::(a)</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala编程</tag>
      </tags>
  </entry>
  <entry>
    <title>scala函数跟闭包</title>
    <url>/2020/09/22/scala%E5%87%BD%E6%95%B0%E8%B7%9F%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>需要注意的是使用字面量函数以及符号<code>=&gt;</code>的使用，闭包好比作用域，用于确定变量的范围</p>
<a id="more"></a>
<ul>
<li><p>函数字面量**</p>
<p>函数字面量存在于源码中，在运行时编译成类，并在运行时实例化为函数值，所以函数值对象形式存在于运行时</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">(x: <span class="type">Int</span>) =&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上述例子时函数字面量，左侧时参数列表，右侧是操作，多条语句的话，使用<code>&#123;&#125;</code>进行组合，<code>=&gt;</code>的意思表示将左侧的内容转换为右侧的内容。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">someNumbers.filter(x =&gt; x &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>接受一个函数做为入参，并对列表中的每个元素调用这个函数。同时由于知道了<code>someNumbers</code>是整数，所以x必定是整数，不用再申明类型</p>
</li>
<li><p><strong>占位符语法</strong></p>
<p>用占位符来表示一个或多个参数，只要满足每个参数只在函数字面量中出现一次就行，第一个下划线代表第一个参数，第二个下划线代表第二个参数，第三个下划线代表第三个参数，以此类推。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">someNumber.filter(_ &gt; <span class="number">0</span>)  <span class="comment">//变量是啥都不管</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>部分应用函数</strong></p>
<p>可以用<code>_</code>代替独立的参数列表，但是要与主函数之间加上空格。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Int</span>): <span class="type">Int</span> = a + b + c</span><br><span class="line"><span class="keyword">val</span> a = sum _  <span class="comment">//_ 表示的是三个参数的参数列表 可以通过a(1, 2, 3)调用</span></span><br><span class="line"><span class="keyword">val</span> b = sum(<span class="number">1</span>, _: <span class="type">Int</span>, <span class="number">3</span>)  <span class="comment">//可以调用b(2)</span></span><br><span class="line">someNumbers.foreach(println _)</span><br><span class="line">someNumbers.foreach(println)</span><br></pre></td></tr></table></figure>

<p>最后的这两种形式，可以再明确需要函数的地方给出。</p>
</li>
<li><p><strong>闭包</strong></p>
<p>函数字面量创建出来的函数值被称为闭包，该名称源于“捕获”其自由变量从而“闭合”该函数字面量的操作。没有自由变量的字面量成为闭合语，比如<code>(x: Int =&gt; x + 1)</code>。任何带有自由变量的函数字面量称为开放语，比如<code>(x: Int =&gt; x + more)</code></p>
</li>
<li><p><strong>特殊函数的调用形式</strong></p>
<ul>
<li><p>重复参数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span></span>(args: <span class="type">String</span>*) = </span><br><span class="line">	<span class="keyword">for</span> (arg &lt;- args) println(arg)</span><br><span class="line">echo(arr: _*)  <span class="comment">//传入一个String类型的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>缺省值参数，带名参数</p>
<p>缺省值参数就是将参数提前赋值，与python中一致。</p>
<p>带名参数的作用就是再调用过程中，参数的顺序可以被打乱。</p>
</li>
</ul>
</li>
<li><p><strong>尾递归</strong></p>
<p>在函数的尾部自己调用自己，这样的话就是尾递归，尾递归会自动的优化成<code>while</code>循环的形式，减少栈的开销。但是只能对那些直接尾递归的函数进行优化，要是间接的调用尾递归并不会进行优化</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEven</span></span>(x: <span class="type">Int</span>): <span class="type">Boolean</span> = </span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">0</span>) <span class="literal">true</span> <span class="keyword">else</span> isOdd(x - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isodd</span></span>(x: <span class="type">Int</span>): <span class="type">Boolean</span> = </span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">0</span>) <span class="literal">false</span> <span class="keyword">else</span> isEven(x - <span class="number">1</span>)  <span class="comment">//这样的相互递归不会优化，最后一步调用的是另外的一个函数值，并不会进行优化</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala编程</tag>
      </tags>
  </entry>
</search>
