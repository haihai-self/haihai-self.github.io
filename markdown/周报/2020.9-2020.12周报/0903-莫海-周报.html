<h1 id="0903-莫海-周报"><a href="#0903-莫海-周报" class="headerlink" title="0903-莫海-周报"></a>0903-莫海-周报</h1><p>[TOC]</p>
<h2 id="GenerateSimFiles"><a href="#GenerateSimFiles" class="headerlink" title="GenerateSimFiles"></a>GenerateSimFiles</h2><p>该命令主要是拷贝编译所所需要的文件到目标文件夹，调用的是<code>generators\utilities\src\main\scala\Simulator.scala</code>中的<code>GenerateSimFiles</code>函数，该函数混入了<code>HasGenerateSimConfig</code>特质，该特质决定传入的传输选项。</p>
<ul>
<li><p><strong>sim/simulator</strong></p>
<p>通过模式匹配决定使用仿真的软件是<code>vcs</code>还是<code>simulator</code></p>
</li>
<li><p><strong>td/target-dir</strong></p>
<p>需要拷贝到的目标文件夹</p>
</li>
<li><p><strong>df/dotFName</strong></p>
<p>生成的dot-f文件的名称</p>
</li>
</ul>
<p>参数的使用的是<code>scala</code>中的<code>scopt.OptionParser</code>对象进行判断调用，同时也通过该对象的<code>parser</code>成员函数判断是否参数匹配，对匹配的参数进行下一步操作，即调用<code>GenerateSimFiles</code>对象的内部关系</p>
<ul>
<li>首先调用<code>writeFiles</code>函数，此函数为该类中的入口函数，其他的函数都通过该函数进行初始的调度。</li>
<li>在writeFiles中首先创建一个<code>boorrom</code>文件夹，并拷贝一些img文件到该文件夹</li>
<li>创建传入参数的目标文件夹</li>
<li>将<code>resources</code>中需要的依赖文件拷贝到目标文件夹</li>
<li>使用<code>writeDotF</code>函数保存成<code>dot-f</code>文件</li>
</ul>
<p><img src="picture/GenerateSimfile.svg" alt="GenerateSimfile"></p>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>命令中的<code>GENERATOR_PACKAGE</code>变量很多都是为<code>chipyard</code>，所以我主要关注了该package下的<code>generator</code>函数。该函数主要作用是设置<code>FIRRTL</code>的一些编译选项，控制编译的时候的一些行为，所在目录为<code>generators\chipyard\src\main\scala\Generator.scala</code>，通过<code>StageMain</code>对象传入一个<code>ChipyardStage</code>对象，我主要关注了ChipyardStage中的一些编译选项，而在StageMain中则主要是一些FIRRTL的状态转换以及行为控制、消息传递，没有仔细去进行分析。</p>
<h3 id="ChipyardStage"><a href="#ChipyardStage" class="headerlink" title="ChipyardStage"></a>ChipyardStage</h3><p>在ChipyardStage中主要有两个比较重要的成员，一个是<code>Shell</code>成员另外一个是<code>target</code>成员，其中Sell成员主要是控制编译器的行为，而target成员主要调用FIRRTL中的<code>Depedency</code>对象，目的是找到一些依赖的库与生成编译过程中的log。</p>
<p><strong>shell</strong></p>
<p>该成员通过混入了<code>ChipyardCli</code>, <code>RocketChipCli </code>, <code>ChiselCli </code>, <code>FirrtlCli</code>四个特质来接守输入的参数，同时控制编译器的行为。</p>
<ul>
<li><p><strong>ChipyardCli</strong></p>
<p>该特质接收chipyard的生成选项，接收参数为<code>legacy-configs</code>，接受一串以下划线界定的参数，参数的优先级从右到左递减。参数切分处理之后还会进一步调用<code>ConfigsAnnotation</code>生成FIRRTL接收的<code>Annotation</code>类，在接下来的篇幅中会进一步介绍，该特质的思维导图如下所示。</p>
<p><img src="picture/ChipyardCli.svg" alt="ChipyardCli"></p>
</li>
<li><p><strong>RocketChipCli</strong><br>该特质是<code>RocketChip</code>的编译选项，其中有三个类来处理该编译的参数，分别为<code>TopModuleAnnotation </code>, <code>OutputBaseNameAnnotation</code>,  <code>ConfigsAnnotation</code>, </p>
<ul>
<li><p>TopModuleAnnotation</p>
<p>接收参数<code>top-module/T</code>，将输入的顶层模块参数转化为Annotation传递给<code>FIRRTL</code></p>
</li>
<li><p>ConfigsAnnotation</p>
<p>接收参数<code>configs/c</code>，配置参数以句点字符串进行配置，切分之后以<code>Annotation</code>的形式传递给<code>FIRRTL</code></p>
</li>
<li><p>OutputBaseNameAnnotation</p>
<p>接收参数<code>name/n</code>，设置基础的输出文件名</p>
</li>
</ul>
<p><img src="picture/RocketChipCli.png" alt="RocketChipCli"></p>
</li>
<li><p><strong>ChiselCli</strong></p>
<p>该特质是<code>chisel</code>的编译选项，选择是否使用<code>FIRRTL</code>，跟踪打印在<code>transform</code>过程中发生异常的信息，chisel生成Annotaion的选项等，他通过三个类来实现上述的目标，分别为<code>NoRunFirrtlCompilerAnnotation</code>, <code>PrintFullStackTraceAnnotation</code>, <code>ChiselGeneratorAnnotation</code>。</p>
<ul>
<li><p>NoRunFirrtlCompilerAnnotation</p>
<p>接收参数<code>no-run-firrtl/chnrf</code>，使用了该选项就不使用<code>FIRRTL</code>进行编译，直接由chisel得到硬件电路。</p>
</li>
<li><p>PrintFullStackTraceAnnotation</p>
<p>接收参数<code>full-stacktrace</code>，即当发生异常的时候，将会以栈的形式全打印出来</p>
</li>
<li><p>ChiselGeneratorAnnotation</p>
<p>接收参数<code>module</code>，通过给出类的名字跟路径搭一个chisel module，且不能带参数，要是找不到将会抛出异常。</p>
<p><img src="C:%5CUsers%5Cmohai%5Cworkspace%5Cchipyard_note%5CChiselCli.svg" alt="ChiselCli"></p>
</li>
</ul>
</li>
<li><p><strong>FirrtlCli</strong></p>
<p>该特质是FIRRTL编译器的编译选项，主要通过<code>FirrtlFileAnnotation</code>, <code>OutputFileAnnotation</code>, <code>InfoModeAnnotation</code>, <code>FirrtlSourceAnnotation</code>, <code>CompilerAnnotation</code>, <code>RunFirrtlTransformAnnotation</code>, <code>EmitCircuitAnnotation</code>, <code>EmitAllModulesAnnotation</code>, <code>NoCircuitDedupAnnotation</code>，这些特质实现对编译选项的识别与对应函数的执行</p>
<p><img src="picture/FirrtlCli.svg" alt="FirrtlCli"></p>
</li>
</ul>
<h2 id="GenerateTopAndHarness"><a href="#GenerateTopAndHarness" class="headerlink" title="GenerateTopAndHarness"></a>GenerateTopAndHarness</h2><p>该函数也是FIRRTL的一些编译选项，但与上面不同的是，此处控制的主要是编译成的目标代码的电路结构，上面主要是FIRRTL编译器编译之前的一些选项，如输入输出文件啦，中间过程如何转化等。</p>
<p>同时生成了很多</p>
<p>同时他不直接在<code>GenerateTopAndHarness</code>中处理信息，这只是一个接口，他通过继承<code>GenerateTopAndHarnessApp</code>，然后调用GenerateTopAndHarnessApp中相应的执行函数进行。</p>
<p>该函数主要通过继承<code>HasFirrtlOptions</code>与<code>HasTapeoutOptions</code>来处理参数选项。</p>
<p>其中<code>HasTapeoutOptions</code>主要是用来控制生成RTL的代码结构的特质，而<code>HasFirrtlOptions</code>我个人觉得还是关于FIRRTL中参数传递，中间转换的一些编译控制选项，与之前的有一部分是重叠。</p>
<p>解释中主要分为两个阶段，第一个阶段是收集在<code>synTop</code>之下的模块，第二阶段是删除所有的module然后生成测试工具。</p>
<p>具体的编译选项跟描述如下表所示。</p>
<p><img src="picture/GenerateTopAndHarness.svg" alt="GenerateTopAndHarness"></p>
<h2 id="MacroCompilerc"><a href="#MacroCompilerc" class="headerlink" title="MacroCompilerc"></a>MacroCompilerc</h2><p>这个函数比较复杂，调用了两次，大概是生成不同层次的memory，接下来还需要配合文档在仔细阅读，两次调用此一次大概是生成<code>TOP_SMEMS</code>，第二次生成的是<code>HARNESS_SMEMS</code>，具体如何生成的我先不去理解，这里先列举他的参数配置相关的内容，具体如下表所示。</p>
<p><img src="picture/MacroCompiler.svg" alt="MacroCompiler"></p>
<h2 id="总结-amp-amp-Todo"><a href="#总结-amp-amp-Todo" class="headerlink" title="总结&amp;&amp;Todo"></a>总结&amp;&amp;Todo</h2><p><strong>总结</strong>这只是单纯的看了<code>common.mk</code>得到的相应的部分编译配置，在全局搜索看那些模块调用了common.mk发现，其实很多都是独立的模块，包括在前面文档中编译过的VCS或者Verilator其实都有调用，其实都调用了common.mk，但是肯定不止是这几个文件就可以生成对应的仿真工具的。还有就是一些编译选项具体所指有点不明白，需要进一步去看文档，比如所在<code>MacroCompiler</code>中的<code>HARNESS_SMEMS</code>这个选项具体到底是想要生成的那一部分的menory需要具体再去细看。</p>
<p><strong>todo</strong>接下来还需要去看下文档，包括他的具体的设计结构，也就是相关的设计的层次结构，然后再回来看这个编译文档可能会得到更多的新搜获</p>
