<h2 id="为什么scala"><a href="#为什么scala" class="headerlink" title="为什么scala"></a>为什么scala</h2><p>scala不是一门纯粹的面向对象的语言，他强调函数式编程，函数式编程的两大核心理念是函数是一等的，以及程序中应该将值直接映射到输出，尽量的减少在函数中对程序的副作用。</p>
<ul>
<li><p>一等函数</p>
<p>函数可以做为别的函数的参数、返回值，赋值给变量</p>
</li>
<li><p>直接映射到输出</p>
<p>操作直接将输入值映射到输出值，而不是当场修改数据。</p>
</li>
</ul>
<p><strong>变量定义</strong>：变量分为两种，一周是val类型，一种是var类型，val类型一旦被初始化就不能修改其值，var类型在整个生命周期之内都可以被重新赋值。</p>
<p><strong>函数定义</strong>：def开始，接下来是函数名，之后吃参数列表，紧跟一个冒号，之后是返回类型，接下来是等号，花括号之内是函数体</p>
<pre><code class="scala"> def max(x: int, y:Int): Int = {
  if(x &gt; y)
    x
  else
    y
}</code></pre>
<p><strong>函数字面量</strong>：用圆括号括起来一组带名字的参数，一个又箭头和函数体</p>
<pre><code class="scala">(x: Int, y: Int) =&gt; x + y</code></pre>
<p><strong>foreach,跟for遍历</strong></p>
<pre><code class="scala">args.foreach(arg =&gt; println(arg))

for(arg &lt;- args)
    println(arg)

for(i &lt;- 0 to 2)
    println(i)
//for括号中，左边是变量，右边是数组</code></pre>
<p>方法调用：在scala中并没有操作符重载，1 + 2被解释成(1).+(2)调用Int的+方法</p>
<p><strong>从文件读取文本行</strong>：</p>
<pre><code class="scala">import scala.io.Source
if(args.length &gt; 0){
  for(line &lt;- Source.fromFile(args(0)).getLines())
    println(line.length + &quot; &quot; + line)
}
else 
  Console.err.println(&quot;please enter filename&quot;)</code></pre>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><strong>类的定义</strong></p>
<pre><code class="scala">class ClassName(){
} //类的A定义

val a = new ClassName() //实例化

a.method //调用字段方法</code></pre>
<p>若是定义的返回值位uint，其作用就是强调函数的副作用，要是没有<code>return</code>语句，将会将函数中最后的结果做为返回值</p>
<p><strong>单例对象</strong></p>
<p>当有同名类时，单例对象位伴生对象，可以访问<code>伴生类</code>的所有成员变量，其可以存放静态方法，类中不能有静态方法</p>
<pre><code class="scala">object ObjectName{
}</code></pre>
<p>若无<code>伴生类</code>则位孤立对象，其中可以用maim方法</p>
<pre><code class="scala">object Summer{
  def main(args: Array[String]) = {
    for(arg &lt;- args)
      println(&quot;hello world&quot;)
  }
}
</code></pre>
<p>直接使用scala命令进行编译，时间会比较长，因为他会遍历jar所有的包，使用<code>fsc</code>进行编译，第一次时间比较长，之后会创建一个<code>守护进程</code>若是程序没有改动，则时间上会很快</p>
<h2 id="基础类型跟操作"><a href="#基础类型跟操作" class="headerlink" title="基础类型跟操作"></a>基础类型跟操作</h2><ul>
<li><p><strong>字面量</strong>：是表达源码中一个固定值的方法</p>
</li>
<li><p><strong>字符串字面量</strong>：这里需要注意的是若是有 <code>&quot;&quot;&quot;</code>括起来的字符串将不会进行转译</p>
</li>
<li><p><strong>符号字面量</strong>：<code>&#39;ident</code>这样的形势，用来再动态语言中当作标识符的场合</p>
</li>
<li><p><strong>字符串插值</strong>：<code>s&quot; $name&quot;</code>将回去寻找变量name，对字符串中的<code>name</code>进行插值，还可以使用f插值如<code>f&quot;{math.Pi}%.5f&quot;</code>进行printf风格的插值，row插值将不会对<code>\</code>进行转译</p>
</li>
<li><p><strong>操作符即方法</strong></p>
<p>调用1 + 3 这样的方法，会调用<code>1.+(3)</code>，同时，任何方法都是操作符，<code>s.indexOf(&#39;o&#39;)</code>可以写成<code>s indexOf &#39;o&#39;</code></p>
<p>前缀标识符：+ - ! ~ 会表示成<code>p.unary_!</code>这样的类似形式g</p>
<p>后缀标识符是那些不接受参数且再调用时没有英文句点圆括号的方法，可以再调用的时候省区圆括号，如<code>s.length</code>返回字符串<code>s</code>的长度</p>
</li>
<li><p><strong>无符号右移</strong>： <code>&gt;&gt;&gt;</code>左移跟无符号右移都会自动填充0</p>
</li>
<li><p><strong>对象相等</strong>：直接使用<code>==</code>的方法，可以直接比较对象的内容上相等。</p>
</li>
<li><p><strong>结合性</strong>：任何<code>:</code>的方法都由他右边的对象调用，传入左侧的操作元。<code>a:::b</code>将会是<code>b.:::(a)</code></p>
</li>
</ul>
<h2 id="函数式对象"><a href="#函数式对象" class="headerlink" title="函数式对象"></a>函数式对象</h2><p>如果一个类没有定义体，并不需要给出花括号，因为没有显示的构造方法，若需要检查一些前置条件的话，需要用到<code>require</code>这个方法</p>
<pre><code class="scala">class Rational(n: Int, d: Int){
    require(d != 0)  //检查分母不能为0
    override def toString = n + &quot;/&quot; + d //没有参数的话可以直接写 =
}</code></pre>
<p><code>n, d</code>做为类参数，scala编译器会自动采集到这两个参数，并创建一个主构造方法，同时接受这两个参数。</p>
<p>重写<code>toString</code>方法：因为编写一个类之后，新建他会打印初该类的一些默认信息，要是没有从写<code>toString</code>方法的话会导致打印的只是地址</p>
<pre><code class="scala">class Rational(n: Int, d: Int){
    override def toString = n + &quot;/&quot; + d
}</code></pre>
<p><strong>辅助构造方法</strong>：相当于多态，以<code>def this</code>打头，但是辅助构造放法必须调用<code>主构造方法</code>或者调用同一个类中的<code>另外一个构造方法</code>，但这个构造方法最终还是会调用主构造方法，主构造方法是类的单一入口，因为只有主构造方法才能调用<code>超类</code></p>
<pre><code class="scala">class Rational(n: Int, d: Int){
    def this(n: Int) = this(n, 1)
}</code></pre>
<p><strong>变量定义</strong>：先申明为<code>val或var</code>之后定义标识符，最后定义类型，若是val需要给出初始化参数（正常情况下），但是要是标识符以下划线结尾，需要再标识符与冒号之间加上<code>空格</code></p>
<pre><code class="scala">val n: Int = 1
val n_ : Int = 1</code></pre>
<p><strong>隐式转换</strong>：重载了操作符之后就可以进行运算了，比如 r * 2这样的方法没问题，操作符的左结核性会调用r对应的 * 方法，但是使用2 * r 这样的方法并不行，因为Int类型并没有定义 * r的方法，若想调用，需要加入隐式转换</p>
<pre><code class="scala">implicit def intToRational(x: Int) = new Rational(x)</code></pre>
<p>该方法将int转换为Rational类型，之后在调用Rational的 * 方法 </p>
<p>Rational程序例子：</p>
<pre><code class="scala">class Rational(d: Int, n: Int){
  require(d != 0)
  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / g

  def this(n: Int) = this(n, 1)
  def + (that: Rational): Rational = 
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
      )

  def + (i: Int):Rational = 
    new Rational(numer + i * denom, denom)

  def - (that: Rational): Rational = 
    new Rational(numer * that.denom - that.numer * denom,
      denom * that.denom)

  def - (i: Int): Rational = 
    new Rational(numer - i * denom, denom)

  def * (that: Rational): Rational =
    new Rational(numer * that.numer, denom * that.denom)

  def * (i: Int): Rational = 
    new Rational(numer * i, denom)

  def / (that: Rational): Rational = 
    new Rational(numer * that.denom, denom * that.numer)

  def / (i: Int): Rational =
    new Rational(numer, denom * i)

  override def toString = numer + &quot;/&quot; + denom
  private def gcd(a: Int, b: Int): Int =
    if(b == 0) a else gcd(b, a % b)

}</code></pre>
<h2 id="内建的控制结构"><a href="#内建的控制结构" class="headerlink" title="内建的控制结构"></a>内建的控制结构</h2><ul>
<li><p><strong>if表达式</strong></p>
<p>首先测试条件，根据条件是否满足来执行两个不同代码分支中的一个</p>
<pre><code class="scala">println(if (!args.isEnpty) args(0) else &quot;default.txt&quot;)</code></pre>
</li>
<li><p><strong>for循环</strong></p>
<pre><code class="scala">for (file &lt;- filesName)
    println(file)</code></pre>
<p>像<code>file &lt;- filesName</code>这样的语法是生成器，遍历filsname中的所有元素</p>
</li>
<li><p><strong>过滤</strong></p>
<pre><code class="scala">for (file &lt;- filesName if file.getName.endWith(&quot;.scala&quot;))
    println(file)</code></pre>
<p>使用if子句进行过滤</p>
</li>
<li><p><strong>嵌套循环</strong></p>
<p>使用多个<code>&lt;-</code>子句，将会先遍历外层迭代器，在根据条件遍历内层迭代器，还可以在中途绑定变量。</p>
<pre><code class="scala">for (
    file &lt;- filesName
    if file.getName.endWith(&quot;.scala&quot;)
    line &lt;- fileLines(file)
    trimed = line.trim
    if trimed.matchs(pattern)
)println(file + &quot;:&quot; line.trim)</code></pre>
</li>
<li><p><strong>产出一个新的集合</strong></p>
<p>在for循环的后面加上<code>yield</code>关键字将会产生一个集合，如<code>for</code> 子句 <code>yield</code> 代码体</p>
<pre><code class="scala">def scalaFiles = 
    for{
        file &lt;- filesName
        if file.getName.endsWith(&quot;.scala&quot;)
    }yield file</code></pre>
</li>
<li><p><strong>捕获处理异常</strong></p>
<p>try：代码体</p>
<p>cache：捕获处理异常，且里面用cace进行匹配</p>
<p>finally：不管咋样都要执行的代码</p>
</li>
<li><p><strong>没有break跟continue</strong></p>
<p>通过使用变量<code>var</code>来进行控制，要是实在是需要break支持，可以在<code>scala.util.control.Braks._</code>中找到</p>
</li>
</ul>
<h2 id="函数跟闭包"><a href="#函数跟闭包" class="headerlink" title="函数跟闭包"></a>函数跟闭包</h2><ul>
<li><p><strong>函数字面量</strong></p>
<p>函数字面量存在于源码中，在运行时编译成类，并在运行时实例化为函数值，所以函数值对象形式存在于运行时</p>
<pre><code class="scala">(x: Int) =&gt; x + 1</code></pre>
<p>上述例子时函数字面量，左侧时参数列表，右侧是操作，多条语句的话，使用<code>{}</code>进行组合，<code>=&gt;</code>的意思表示将左侧的内容转换为右侧的内容。</p>
<pre><code class="scala">someNumbers.filter(x =&gt; x &gt; 0)</code></pre>
<p>接受一个函数做为入参，并对列表中的每个元素调用这个函数。同时由于知道了<code>someNumbers</code>是整数，所以x必定是整数，不用再申明类型</p>
</li>
<li><p><strong>占位符语法</strong></p>
<p>用占位符来表示一个或多个参数，只要满足每个参数只在函数字面量中出现一次就行，第一个下划线代表第一个参数，第二个下划线代表第二个参数，第三个下划线代表第三个参数，以此类推。</p>
<pre><code class="scala">someNumber.filter(_ &gt; 0)  //变量是啥都不管</code></pre>
</li>
<li><p><strong>部分应用函数</strong></p>
<p>可以用<code>_</code>代替独立的参数列表，但是要与主函数之间加上空格。</p>
<pre><code class="scala">def sum(a: Int, b: Int, c: Int): Int = a + b + c
val a = sum _  //_ 表示的是三个参数的参数列表 可以通过a(1, 2, 3)调用
val b = sum(1, _: Int, 3)  //可以调用b(2)
someNumbers.foreach(println _)
someNumbers.foreach(println)</code></pre>
<p>最后的这两种形式，可以再明确需要函数的地方给出。</p>
</li>
<li><p><strong>闭包</strong></p>
<p>函数字面量创建出来的函数值被称为闭包，该名称源于“捕获”其自由变量从而“闭合”该函数字面量的操作。没有自由变量的字面量成为闭合语，比如<code>(x: Int =&gt; x + 1)</code>。任何带有自由变量的函数字面量称为开放语，比如<code>(x: Int =&gt; x + more)</code></p>
</li>
<li><p><strong>特殊函数的调用形式</strong></p>
<ul>
<li><p>重复参数</p>
<pre><code class="scala">def echo(args: String*) = 
    for (arg &lt;- args) println(arg)
echo(arr: _*)  //传入一个String类型的数组</code></pre>
</li>
<li><p>缺省值参数，带名参数</p>
<p>缺省值参数就是将参数提前赋值，与python中一致。</p>
<p>带名参数的作用就是再调用过程中，参数的顺序可以被打乱。</p>
</li>
</ul>
</li>
<li><p><strong>尾递归</strong></p>
<p>在函数的尾部自己调用自己，这样的话就是尾递归，尾递归会自动的优化成<code>while</code>循环的形式，减少栈的开销。但是只能对那些直接尾递归的函数进行优化，要是间接的调用尾递归并不会进行优化</p>
<pre><code class="scala">def isEven(x: Int): Boolean = 
    if (x == 0) true else isOdd(x - 1)

def isodd(x: Int): Boolean = 
    if (x == 0) false else isEven(x - 1)  //这样的相互递归不会优化，最后一步调用的是另外的一个函数值，并不会进行优化</code></pre>
</li>
</ul>
<h2 id="抽象控制"><a href="#抽象控制" class="headerlink" title="抽象控制"></a>抽象控制</h2><ul>
<li><p><strong>减少代码重复</strong></p>
<p>利用一等函数与占位符消除代码的重复</p>
<pre><code class="scala">object FileMatcher{
  private def filesHere = (new java.io.File(&quot;.&quot;)).listFiles
  private def filesMatching(matcher: String =&gt; Boolean) = 
    for (file &lt;- filesHere; if matcher(file.getName))
      yield file

  def filesEnding(query: String) = 
    filesMatching(_.endsWith(query))

  def filesContaining(query: String) = 
    filesMatching(_.contains(query))

  def filesRegex(query: String) =
    filesMatching(_.matches(query))
}
</code></pre>
</li>
<li><p><strong>柯里化</strong></p>
<p>支持多个参数列表编写的一种形式，可以通过传入多组参数来应用他，也可以部分应用，然后绑定到变量上，通过变量进行调用</p>
<pre><code class="scala">def curriedSum(x: Int)(y: Int) = x + y
val second = curriedSum(1)_
val twoPlis = second(2)  //1 +２的值，通过部分绑定调用</code></pre>
</li>
<li><p><strong>编写新的控制结构</strong></p>
<p>通过一等函数，与<code>柯里化</code>，将某个控制模式简化。</p>
<pre><code class="scala">def withPrintWriter(flie: File)(op: PrintWriter =&gt; Unit){
    val writer = new printWriter(file)
    try{
    op(writer)
    } finally{
    writer.close()
    }
}

val file = new File(&quot;data.txt&quot;)
withPrintWriter(file){wirter =&gt; writer.println(new java.util.Data)}  //单个参数可以使用花括号</code></pre>
</li>
<li><p><strong>传名参数－传值参数</strong></p>
<p>传值参数中表达式的值将先于函数被调用，而传名参数将会在函数中调用该名字的地方进行调用。其实就是一个参数求值先后的问题。</p>
<pre><code class="scala">def byNameAssert(predicate: =&gt; Boolean) = {
  if (assertionsEnabled &amp;&amp; !predicate)  //传名参数，运行到这里才会进行求值
      throw new AssertionError
}

def boolAssert(predicate: Boolean) = //传值参数，其实在这里predicate就进行求值了
    if (assertionsEnabled &amp;&amp; !predicate)
      throw new AssertionError</code></pre>
</li>
</ul>
<h2 id="组合跟继承"><a href="#组合跟继承" class="headerlink" title="组合跟继承"></a>组合跟继承</h2><ul>
<li><p><strong>抽象成员</strong></p>
<p>申明为一个没有实现方法的成员，包含其的类为抽象类，具体需要在<code>class</code>之前加上<code>abstract</code></p>
</li>
<li><p><strong>无参方法</strong></p>
<p>当函数没有参数列表的时候，参数列表的<code>()</code>都可以省略不写，但是在当其不仅仅表示一个属性，而是将会对某些<code>var</code>产生副作用的时候，将建议写上圆括号</p>
<pre><code class="scala">abstract class Element{
  def contents: Array[String]  //抽象方法，因此需要抽象类
  def height: Int = contents.length  //参数列表省略，调用的时候也可以不使用参数列表
  def width: Int = if (height == 0) 0 else contents(0).height
}</code></pre>
</li>
<li><p><strong>扩展类</strong></p>
<p>通过<code>extends</code>关键字进行类继承，但是只能继承私非私有成员，不能继承私有成员。在重写<code>overide</code>的过程中，字段跟方法不能同名。</p>
</li>
<li><p><strong>定义参数化字段</strong></p>
<p>在类参数前加上<code>val</code>则同时定义参数跟字段。</p>
<pre><code class="scala">class ArrayElement(
    val contents: Array[String]
)extends Element

class ArrayElement(cons: Array[String]) extends Element{  //相当于类定义的这个形式
  val contents: Array[String] = cons
}</code></pre>
</li>
<li><p><strong>调用超类构造方法</strong></p>
<p>只需要将参数放入扩展类后面的圆括号中即可</p>
<pre><code class="scala">class ArrayElement(s: String) extends ArrayElement(Array(s))</code></pre>
</li>
<li><p><strong>多态跟动态绑定</strong></p>
<p>多态就是多种形态，基类可以指向不同的子类来进行实例化，同时要是有不同的子类中有同名函数，将会根据实例化的子类来决定具体调用哪个函数，这样的方法叫做动态绑定。这两个就是一个概念，字面上理解就好，现实应用中也特别的自然。</p>
</li>
<li><p><strong>申明final成员</strong></p>
<p>要是不想某个方法或者字段被重写，可以通过在成员前面添加<code>final</code>字段来达到这样的效果，这样子类中可以继承使用，但是不能被重写。</p>
</li>
<li><p><strong>定义工厂对象</strong></p>
<p>工厂对象包含创建其他对象的方法。工厂方法使用单例对象来定义创建其他类，最直接的放在父类中，并通过引入来进行从命名。</p>
</li>
</ul>
<h2 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h2><ul>
<li><p><strong>简述</strong></p>
<p>使用关键字<code>trait</code>进行特质的使用，同时可以使用<code>extends</code>跟<code>with</code>将特质混入到类中，其中使用<code>extends</code>进行特质的混入会隐式的继承特质中的超类，但是在特质中，不能有任何的类参数（传入类的主构造方法的参数），且与<code>super</code>是进行的动态绑定</p>
<pre><code class="scala">class Frog extends Animal with Philosophical with HasLegs  //通过extends继承某个类，同时可以在用with引入多个特质
trait Philosophical  //特质申明样子

trait Nopoint(x: Int, y: Int)  //错误，不能进行编译</code></pre>
</li>
<li><p><strong>Ordered特质</strong></p>
<p>是一个进行大小比较的特质，使用需要进行两步走，第一是混入<code>Ordered[C]</code>，其中C是你要进行比较的元素类。第二件事是定义一个用来比较两个对象的<code>compare</code>方法，该方法比较两个接受者，要是返回<code>0</code>则两个对象相等，要是返回负值则接收者比入参小，要是为正值，则接受者比入参大。</p>
<pre><code class="scala">class Rational(n: Int, d: Int) extends Ordered[Rational]{
  def compare(that: Rational) = 
      (this.numer * that.denom) - (that.numer * this.denom)
}</code></pre>
</li>
<li><p><strong>作为可叠加修改的特质</strong></p>
<p>就是特质可以为类提供可叠加的修改，及特质修改类的方法，而且允许你将你这些修改叠加起来。且叠加的优先级重要程度是越靠近右边的方法最先被调用，如果方法调用<code>super</code>则最左侧的方法最先被调用。</p>
<pre><code class="scala">abstract class IntQueue{
  def get(): Int
  def put(x: Int)
}

class BasicIntQueue extends IntQueue{
  private val buf = new ArrayBuffer[Int]
  def get() = buf.remove(0)
  def put(x: Int) = { buf += x}
}

trait Doubling extends IntQueue{
  abstract override def put(x: Int) = {super.put(2 * x)}  //对于可叠加的特质，特地申明为abstract override
}

trait Incrementing extends IntQueue{
  abstract override def put(x: Int) = {super.put(x + 1)}
}

trait Filtering extends IntQueue{
  abstract override def put (x: Int) = {
    if(x &gt;= 0) super.put(x)
  }
}

val queue = (new BasicIntQueue with Filtering with Incrementing)  //先调increasing 在调filter</code></pre>
<p>如果是在类中调用了super方法，将会调用最近的一个方法，如果除了最后一个方法之外，所有方法都super，那最终结果就是叠加到一个的行为（叠加）</p>
</li>
</ul>
<h2 id="包和引入"><a href="#包和引入" class="headerlink" title="包和引入"></a>包和引入</h2><ul>
<li><p><strong>打包</strong></p>
<p>使用<code>package</code>关键字进行打包</p>
<pre><code class="scala">package bobsrockets{
  package navigation{

  }
}</code></pre>
<p>顶层包通过<code>__root__</code>进行引入</p>
</li>
<li><p><strong>引入</strong></p>
<p>通过<code>import</code>进行相关包以及函数的引用，同时还可以使用重命名的方法，通过<code>&lt;原名&gt; =&gt; &lt;新名&gt;</code>这样的方法进行重命名</p>
<pre><code class="scala">import Fruits.{Apple =&gt; Ap, Orange}
import Fruits.{Pear =&gt; _, _}  //引入除了Pear的所有包</code></pre>
</li>
<li><p><strong>包对象</strong></p>
<p>每个包都会有一个对象，任何被放在包对象里的定义都会被当做这个包本身成员</p>
<pre><code class="scala">package object bobsdelights{
  def showFruit(fruit: Fruit) = {
    import furit._
    println(name + &quot;s are &quot; + colro)
  }
}

package printmenu
import bobsdelights.showFruit //直接当做成员来使用</code></pre>
</li>
</ul>
<h2 id="断言跟测试"><a href="#断言跟测试" class="headerlink" title="断言跟测试"></a>断言跟测试</h2><ul>
<li><p><strong><code>assert</code>断言</strong></p>
<p>如果<code>condition</code>不满足，则<code>assert(condition)</code>抛出<code>AssertionError</code>。同时还存在另外一个版本，<code>assert(condition, explanation)</code>首先检查条件，要是条件不满足，则给定<code>explanation</code>的<code>AssertionError</code></p>
</li>
<li><p><strong><code>scala</code>测试</strong></p>
<p><code>ScalaTest</code>的核心概念是套件<code>suite</code>，即测试集合。所谓测试，可以是任何带有名称，可以启动，并且要么成功，要么成功，要么失败。</p>
<p><code>ScalaTest</code>提供了风格特质<code>(style trait)</code>，这些特质扩展了<code>suite</code>并提供了不同的测试风格。</p>
<pre><code class="scala">import org.scalatest.FunSuite
import Element.elem

class ElementSuite extends FunSuite{
  test(&quot;elem result shuld have passed width&quot;){  //圆括号内表示的是测试名称
    val ele = elem(&#39;x&#39;, 2, 3)
    assert(ele.width == 2)  //测试内容
  }
}</code></pre>
<p>还可以强调预期结果与实际结果的差</p>
<pre><code class="scala">assertResult(2){
  ele.width
}</code></pre>
<p>如果想检查摸个方法抛出某个预期的异常可以用<code>assertThrows</code></p>
<pre><code class="scala">assertThrowe[IllegalArgumentException]{
  elem(&#39;x&#39;, -2, 3)
}

val caught = 
    intercept[ArithmeticException]{
    1 / 0
  }
assert(caught.getMessage == &quot;/ by zero&quot;)</code></pre>
<p>如何执行一个测试</p>
<pre><code class="scala">scala -cp scalatest.jar TVsetSpec.scala  //编译
scala -cp scakatest.jar org.scalatest.run TVsetSpec.scala  //执行</code></pre>
</li>
</ul>
<h2 id="样例类跟模式匹配"><a href="#样例类跟模式匹配" class="headerlink" title="样例类跟模式匹配"></a>样例类跟模式匹配</h2><ul>
<li><p><strong>样例类</strong></p>
<p>笼统来说，就是将想要匹配的类加上一个<code>case</code>关键字。</p>
<p>首先他会将我们的方法加上一个工厂方法，可以通过<code>Var(“x”)</code>这样的类型来进行类创建而不是<code>new Var(“x”)</code>。</p>
<p>其次是参数列表中的参数都可以隐式的加上一个<code>val</code>前缀，这样的话就可以当做字段来进行处理。</p>
<p>再次编译器会帮我们自然的实现<code>toString, hashCode, equals</code>方法</p>
<p>最后编译器还会帮我们做一个<code>copy</code>方法，该方法可以进行一些参数的修改</p>
<pre><code class="scala">abstract class Expr
case class Var(name: String) extends Expr
case class number(num: Double) extends Expr
case class UpOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr

//使用实例
val v = Var(&quot;x&quot;)
val op = BinOp(&quot;+&quot;, number(1), v)
v.name
println(op)
op.copy(operator = &quot;-&quot;)</code></pre>
</li>
<li><p><strong>模式匹配</strong></p>
<p>具体形式是<code>选择器 match {可选分支}</code>，其中可选分支包括至少一个<code>case</code>，每一个可选分支都包括一个模式以及一个或多个表达式，如果模式匹配了，这些表达式就会被求值。<code>=&gt;</code>将模式与表达式分开。</p>
<p><code>match switch</code>的区别</p>
<ul>
<li><code>match</code>是一个表达式，总是会得到一个值</li>
<li><code>scala</code>的分支不会贯穿到下一个<code>case</code>，若是匹配的话，会隐式的加上一个<code>break</code>进行退出</li>
<li>若是啥都不匹配的话会抛出异常，所以最后需要加上一个通配<code>case</code></li>
</ul>
<pre><code class="scala">def simplifyTop(expr: Expr): Expr = expr match{
  case UnOp(&quot;-&quot;, UnOp(&quot;-&quot;, e)) =&gt; e  //双重取负
  case BinOp(&quot;+&quot;, e, number(0)) =&gt; e  // + 0
  case BinOp(&quot;*&quot;, e, number(1)) =&gt; 1  // * 1
  case _ =&gt; exrp
}</code></pre>
</li>
<li><p><strong>模式种类</strong></p>
<p>所有的模式匹配跟表达式类型十分的相似</p>
<ul>
<li><p><strong>通配模式</strong></p>
<p><code>(_)</code>会匹配任何对象，用来忽略你并不关心的局部</p>
<pre><code class="scala">expr match{
  case BinOp(_, _, _) =&gt; println(expr + &quot;is a binary operation&quot;)  //只关心是一个二源操作
  case _ =&gt; println(&quot;something else&quot;)  //覆盖值处理
}</code></pre>
</li>
<li><p><strong>常量模式</strong></p>
<p>只匹配自己</p>
<pre><code class="scala">expr match{
  case 5 =&gt; &quot;five&quot;
  case Nil =&gt; &quot;the empty list&quot;  //只能匹配空列表
  case _ =&gt; &quot;something else&quot;
}</code></pre>
</li>
<li><p><strong>变量模式</strong></p>
<p>变量模式可以匹配任何对象，这点跟通配模式相同，但是变量模式会将匹配的对象绑定到变量上，这样就可以使用这个变量进行下一步的处理</p>
<pre><code class="scala">expr match{
  case 0 =&gt; &quot;zero&quot;
  case somethingElse =&gt; &quot;not zero&quot; + somethingElse  //这里将somethingElse用作一些处理，但是这还是局部变量
}</code></pre>
<p><code>scala</code>中一般会将<strong>小写</strong>开头的字面量当做<strong>变量匹配</strong>，要是想要继续使用小写开头字面量当做常量的话可以使用<code>this.pi, obj.pi</code>等进行处理</p>
</li>
<li><p><strong>构造方法模式</strong></p>
<p>最有用的模式，由一个名称加上一个圆括号以及圆括号中的模式组成。这个模式将首先检查被匹配的对象是否是以这个名称命名的样例实例，在检查这个对象的够着方法参数是否匹配这些额外给出模式。</p>
<p>这样意味着可以进行深度匹配，不仅仅会检查顶层，还会进一步检查对象内容是否匹配这些额外的模式要求</p>
<pre><code class="scala">expr match{
  case BinOp(&quot;+&quot;, e, number(0)) =&gt; println(&quot;a deep match&quot;)  //首先匹配BinOp，接着匹配参数列表，最后匹配number(0)，一共有三层模式匹配
}</code></pre>
</li>
<li><p><strong>序列模式</strong></p>
<p>可以跟<code>Lsis, Array</code>这些序列进行模式匹配，可以用<code>_*</code>作为模式的最后一个元素，表示的是还可以匹配任意长度的元素。</p>
<pre><code class="scala">expr match{
  case List(0, _*) =&gt; println(&quot;this is a list with beginning 0&quot;)
  case _ =&gt; 
}</code></pre>
</li>
<li><p><strong>元组模式</strong></p>
<p>这里跟序列模式是一样的，只不过将<code>List</code>换成了圆括号</p>
</li>
<li><p><strong>带类型的模式</strong></p>
<p>使用该模式来替代类型测试跟类型转换</p>
<pre><code class="scala">expr match{
  case s: String =&gt; s.length
  case m:Map[_, _] =&gt; m.size
  case _ =&gt; -1
}

//不好的类型转换跟测试
if(x.isInstanceOf[String]){  //类型判断
  val s = x.asInstanceOf[String]  //类型转换
  s.length
}</code></pre>
<ul>
<li><p>擦除类型</p>
<p>无法检查<code>Map中Int到Int</code>的映射，因为采用的都是一个叫做擦除式泛型，但是数组是例外</p>
<pre><code class="scala">expr match{
  case m: Map[Int, Int] =&gt; true  //error Map不支持具体类型检查
  case a: Array[String] =&gt; &quot;yes&quot;  //true 对Array做了特殊处理
  case _ =&gt;
}</code></pre>
</li>
<li><p>变量绑定</p>
<p>除了独自存在的变量模式之外，我们还可以对任何其他模式添加变量，之后在对变量做一些其他的处理，通过<code>@</code>进行比那辆的绑定</p>
<pre><code class="scala">expr match{
  case UpOp(&quot;abs&quot;, e @ UpOp(&quot;abs&quot;, _)) =&gt; e  //变量绑定
  case _ =&gt;
}</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>模式守卫</strong></p>
<p>模式守卫是任何的布尔表达式，如果纯在模式守卫，这个匹配需要在模式守卫为<code>true</code>的时候才会成功</p>
<pre><code class="scala">expr match{
  case m: Int if n&gt; 0 =&gt; println(m)  //打印大于０的数
  case _ =&gt; 
}</code></pre>
</li>
<li><p><strong>密封类</strong></p>
<p>在做模式匹配的过程中，如果想要编译器帮你确保已经列出所有的类了，通常将会申明为密封类<code>sealed</code>，密封类中所有的子类都需要在密封类所在的文件当中，这样我们只需要关心我们已知的子类就可以了</p>
<pre><code class="scala">sealed abstract class Expr
case class Var(name: String) extends Expr
case class number(num: Double) extends Expr
case class UpOp(operation: String, arg: Expr) extends Expr
case class BinOp(operation: String, left: Expr, right: Expr) extends Expr</code></pre>
</li>
<li><p><strong><code>Option</code>类型</strong></p>
<p><code>Option</code>，为一个标准的类型表示可选值，这样的值可以有两种形式<code>Some(x), None</code>，主要是传递参数的时候进行使用，因为有些时候必须需要判断一个对象是否为空，但是在<code>scala</code>中<code>Null</code>并不是一个合法元素，因此不能进行判断，使用<code>Option</code>类型很好的解决了这个问题。</p>
<pre><code class="scala">def show(x: Option[String]) = x match{
  case Some(x) =&gt; s
  case None =&gt; &quot;?&quot;  //Option类型可以有Null
} </code></pre>
</li>
<li><p><strong>偏函数</strong></p>
<p>它只对会作用于指定类型的参数或指定范围值的参数实施计算，超出它的界定范围之外的参数类型和值它会忽略</p>
<p><code>PartialFunction</code>特质规定了两个要实现的方法：<code>apply</code>和<code>isDefinedAt</code>，<code>isDefinedAt</code>用来告知调用方这个偏函数接受参数的范围，可以是类型也可以是值，如果是指定的范围，则返回<code>true</code>否者的话返回<code>false</code>。<code>apply</code>方法用来描述对已接受的值如何处理。</p>
<p>大多数的时候服务的是case，case序列得到的其实就是一个偏函数</p>
<p>自己定义一个偏函数</p>
<pre><code class="scala">new PartialFunction[List[Int], Int]{
  def apply(xs: List[Int]) = xs match{
    case x :: y :: _ =&gt; y
  }
  def isDefinedAt(xs: List[Int]) xs match{
    case x :: y :: _ =&gt; true
    case _ =&gt; false
  }
}</code></pre>
</li>
</ul>
<h2 id="使用列表"><a href="#使用列表" class="headerlink" title="使用列表"></a>使用列表</h2>